# SOLID principles applied in Typescript

## Single-responsibility principle
A class should have one, and only one, reason to change.

## Open-closed principle
Software entities should be open for extension but closed for modification.

## Liskov substitution principle
If S is a declared subtype of T, objects of type S should behave as objects of type T are expected to behave, if they are treated as objects of type T.

## Interface segregation principle
Clients should not be forced to depend upon interfaces that they don't use.

## Dependency inversion principle
A high-level module should not depend on a low-level module; both should depend on abstraction.

## SOLID principles application
A core error individuals often commit while acquainting themselves with these principles is viewing them as ultimate solutions or as magical remedies that will inherently enhance programs. However, this is far from reality. The primary rationale behind this lies in our uncertainty regarding the timing and manner in which circumstances might evolve. Such fluctuations remain unpredictable on a consistent basis.

## DRY, KISS
One must consider additional patterns and principles, such as Don't Repeat Yourself (DRY) and Keep It Simple, Stupid (KISS), alongside their relationship with the SOLID principles. DRY aims to minimize the redundancy of software components by substituting them with abstractions. KISS encourages a preference for simplicity over intricate and convoluted designs. Achieving alignment among these three principles (DRY, SOLID, and KISS) is challenging and cannot be consistently applied in every scenario.
